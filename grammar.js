const name = "Catala"

const tokens = {
  SCOPE: "scope",
  CONSEQUENCE: "consequence",
  DATA: "data",
  DEPENDS: /depends\s+on/,
  DECLARATION: "declaration",
  CONTEXT: "context",
  DECREASING: "decreasing",
  INCREASING: "increasing",
  OF: "of",
  COLLECTION: "collection",
  ENUM: "enumeration",
  INTEGER: "integer",
  MONEY: "money",
  TEXT: "text",
  DECIMAL: "decimal",
  DATE: "date",
  DURATION: "duration",
  BOOLEAN: "boolean",
  SUM: "sum",
  FILLED: "fulfilled",
  DEFINITION: "definition",
  STATE: "state",
  LABEL: "label",
  EXCEPTION: "exception",
  DEFINED_AS: "equals",
  MATCH: "match",
  WILDCARD: "anything",
  WITH: /with\s+pattern/,
  UNDER_CONDITION: /under\s+condition/,
  IF: "if",
  THEN: "then",
  ELSE: "else",
  CONDITION: "condition",
  CONTENT: "content",
  STRUCT: "structure",
  ASSERTION: "assertion",
  VARIES: "varies",
  WITH_V: "with",
  FOR: "for",
  ALL: "all",
  WE_HAVE: /we\s+have/,
  FIXED: "fixed",
  BY: "by",
  RULE: "rule",
  EXISTS: "exists",
  IN: "in",
  SUCH: "such",
  THAT: "that",
  AND: "and",
  OR: "or",
  XOR: "xor",
  NOT: "not",
  MAXIMUM: "maximum",
  MINIMUM: "minimum",
  FILTER: "filter",
  MAP: "map",
  INIT: "initial",
  CARDINAL: "number",
  YEAR: "year",
  MONTH: "month",
  DAY: "day",
  TRUE: "true",
  FALSE: "false",
  INPUT: "input",
  OUTPUT: "output",
  INTERNAL: "internal",
  RoundMoney: "round_money",
  RoundDecimal: "round_decimal",
  IntToDec: "integer_to_decimal",
  GetDay: "get_day",
  GetMonth: "get_month",
  GetYear: "get_year",
  DECIMAL_LITERAL: /[0-9]+.[0-9]*/,
  MONEY_AMOUNT: /\$[0-9]([0-9,]*[0-9])?(\.[0-9]{0,2})?/,
  DIVMONEY: '/$',
  GREATER_EQUAL_MONEY: '>=$',
  GREATER_MONEY: '>$',
  LESSER_EQUAL_MONEY: '<=$',
  LESSER_MONEY: '<$',
  MINUSMONEY: '-$',
  MULTMONEY: '*$',
  PLUSMONEY: '+$',
  LAW_INCLUDE: 'Include',
// International tokens needing no translation (so far) below
  ALT: '--',
  AT_PAGE: /@\s*p.\s*[0-9]+/,
  BEGIN_CODE: token.immediate('```catala'),
  BEGIN_DIRECTIVE: token.immediate('>'),
  BEGIN_METADATA: token.immediate('```catala-metadata'),
  COLON: ':',
  CONSTRUCTOR: /[A-Z][A-Za-z0-9_']*/,
  DIRECTIVE_ARG: /\S+/,
  DIV: '/',
  DIVDEC: '/.',
  DIVDURATION: '/^',
  DOT: '.',
  END_CODE: '```',
  END_DIRECTIVE: '\n',
  EQUAL: '=',
  GREATER: '>',
  GREATER_DATE: '>@',
  GREATER_DEC: '>.',
  GREATER_DURATION: '>^',
  GREATER_EQUAL: '>=',
  GREATER_EQUAL_DATE: '>=@',
  GREATER_EQUAL_DEC: '>=.',
  GREATER_EQUAL_DURATION: '>=^',
  IDENT: /[a-z][a-zA-Z0-9_']*/,
  INT_LITERAL: /[0-9]+/,
  LAW_HEADING: token.immediate(/#+\s*[^\n]+/),
  LAW_TEXT: /([^`#\n]|`[^`\n]|``[^`\n])[^\n]*|`|``/,
  LBRACKET: '{',
  LESSER: '<',
  LESSER_DATE: '<@',
  LESSER_DEC: '<.',
  LESSER_DURATION: '<^',
  LESSER_EQUAL: '<=',
  LESSER_EQUAL_DATE: '<=@',
  LESSER_EQUAL_DEC: '<=.',
  LESSER_EQUAL_DURATION: '<=^',
  LPAREN: '(',
  LSQUARE: '[',
  MINUS: '-',
  MINUSDATE: '-@',
  MINUSDEC: '-.',
  MINUSDURATION: '-^',
  MULT: '*',
  MULTDEC: '*.',
  NOT_EQUAL: '!=',
  PERCENT: '%',
  PLUS: '+',
  PLUSDATE: '+@',
  PLUSDEC: '+.',
  PLUSDURATION: '+^',
  PLUSPLUS: '++',
  RBRACKET: '}',
  RPAREN: ')',
  RSQUARE: ']',
  SEMICOLON: ';',
  VERTICAL: '|'
}

const inline = $ => [
  // $.law_text,
]

const word = $ => $.IDENT

const rules = {
  COMMENT: $ => seq('#', /[^\n]*/),
  _newline: $ => /[ \t]*\r?\n[ \t]*/,
  // newline tokens need to be explicit outside of code blocks, to properly
  // detect beginnings of lines; add them to the choice of toplevel items and make all tokens "immediate"
  _law_line: $ => prec(0,seq($.LAW_TEXT, $._newline)),
  law_text: $ => prec(1,repeat1($._law_line)),
  metadata_block: $ =>
    seq($.BEGIN_METADATA, // optional($.LAW_TEXT), removed, I don't get what's expected here
      optional($.code),
      $.END_CODE)
}

const extras = $ => [
  /\s/, $.COMMENT
]

module.exports = grammar({
  name: name,
  inline: inline,
  word: word,
  extras: extras,
  rules: Object.assign({
    source_file: $ => repeat($._source_file_item),
    aggregate: $ =>
      seq($.aggregate_func, $.FOR, $._ident, $.IN, $._primitive_expression,
        $.OF, $._base_expression),
    aggregate_func: $ =>
      choice(seq($.CONTENT, $.MAXIMUM, $._typ_base, $.INIT,
               $._primitive_expression),
        seq($.CONTENT, $.MINIMUM, $._typ_base, $.INIT,
          $._primitive_expression),
        seq($.MAXIMUM, $._typ_base, $.INIT, $._primitive_expression),
        seq($.MINIMUM, $._typ_base, $.INIT, $._primitive_expression),
        seq($.SUM, $._typ_base), $.CARDINAL, $.FILTER, $.MAP),
    assertion: $ =>
      choice(seq(optional($.condition_consequence), $._assertion_base),
        seq($.FIXED, $.qident, $.BY, $._ident),
        seq($.VARIES, $.qident, $.WITH_V, $._base_expression,
          optional($._variation_type))),
    _assertion_base: $ => $.expression,
    _atomic_expression: $ =>
      choice($.IDENT, $.literal, seq($.LPAREN, $.expression, $.RPAREN)),
    _base_expression: $ =>
      choice($._primitive_expression, $.aggregate,
        seq($._primitive_expression, $.OF, $._base_expression),
        seq($._primitive_expression, $.WITH, $.constructor_binding),
        seq($._primitive_expression, $.IN, $._base_expression)),
    code: $ => repeat1($.code_item),
    code_item: $ =>
      choice(seq($.SCOPE, $._constructor, optional($.scope_use_condition),
               $.COLON, repeat1($._scope_item)),
        seq($.DECLARATION, $.STRUCT, $._constructor, $.COLON,
          repeat($.struct_scope)),
        seq($.DECLARATION, $.SCOPE, $._constructor, $.COLON,
          repeat1($.scope_decl_item)),
        seq($.DECLARATION, $.ENUM, $._constructor, $.COLON,
          repeat($.enum_decl_line))),
    _collection_marked: $ => $.COLLECTION,
    _compare_expression: $ =>
      choice($._sum_expression,
        seq($._sum_expression, $._compare_op, $._compare_expression)),
    _compare_op: $ =>
      choice($.LESSER, $.LESSER_EQUAL, $.GREATER, $.GREATER_EQUAL,
        $.LESSER_DEC, $.LESSER_EQUAL_DEC, $.GREATER_DEC, $.GREATER_EQUAL_DEC,
        $.LESSER_MONEY, $.LESSER_EQUAL_MONEY, $.GREATER_MONEY,
        $.GREATER_EQUAL_MONEY, $.LESSER_DATE, $.LESSER_EQUAL_DATE,
        $.GREATER_DATE, $.GREATER_EQUAL_DATE, $.LESSER_DURATION,
        $.LESSER_EQUAL_DURATION, $.GREATER_DURATION,
        $.GREATER_EQUAL_DURATION, $.EQUAL, $.NOT_EQUAL),
    condition: $ => seq($.UNDER_CONDITION, $.expression),
    condition_consequence: $ => seq($.condition, $.CONSEQUENCE),
    _condition_pos: $ => $.CONDITION,
    _constructor: $ => $.CONSTRUCTOR,
    constructor_binding: $ =>
      seq($.maybe_qualified_constructor, optional($.optional_binding)),
    _date_int: $ => $.INT_LITERAL,
    definition: $ =>
      seq(optional($.label), optional($.exception_to), $.DEFINITION,
        $.qident, optional($.definition_parameters), optional($.state),
        optional($.condition_consequence), $.DEFINED_AS, $.expression),
    definition_parameters: $ => seq($.OF, $._ident),
    enum_decl_line: $ =>
      seq($.ALT, $._constructor, optional($.enum_decl_line_payload)),
    enum_decl_line_payload: $ => seq($.CONTENT, $._typ),
    enum_inject_content: $ => seq($.CONTENT, $._small_expression),
    exception_to: $ => seq($.EXCEPTION, optional($._ident)),
    _exists_marked: $ => $.EXISTS,
    exists_prefix: $ =>
      seq($._exists_marked, $._ident, $.IN, $._primitive_expression, $.SUCH,
        $.THAT),
    expression: $ =>
      choice(seq($.exists_prefix, $.expression),
        seq($.forall_prefix, $.expression),
        seq($.MATCH, $._primitive_expression, $.WITH, optional($.match_arms)),
        seq($.IF, $.expression, $.THEN, $.expression, $.ELSE, $.expression),
        $._logical_expression),
    for_all_marked: $ => seq($.FOR, $.ALL),
    forall_prefix: $ =>
      seq($.for_all_marked, $._ident, $.IN, $._primitive_expression,
        $.WE_HAVE),
    _ident: $ => $.IDENT,
    label: $ => seq($.LABEL, $._ident),
    _law_heading: $ => $.LAW_HEADING,
    law_text: $ => repeat1($.LAW_TEXT),
    literal: $ =>
      choice(seq($._num_literal, optional($._unit_literal)), $.MONEY_AMOUNT,
        seq($.VERTICAL, $._date_int, $.MINUS, $._date_int, $.MINUS,
          $._date_int, $.VERTICAL), $.TRUE, $.FALSE),
    _logical_and_op: $ => $.AND,
    _logical_atom: $ => $._compare_expression,
    _logical_expression: $ =>
      choice($._logical_or_expression,
        seq($._logical_or_expression, $._logical_and_op,
          $._logical_expression)),
    _logical_or_expression: $ =>
      choice($._logical_atom,
        seq($._logical_atom, $._logical_or_op, $._logical_or_expression)),
    _logical_or_op: $ => choice($.OR, $.XOR),
    _loption_separated_nonempty_list_SEMICOLON_expression__: $ =>
      $._separated_nonempty_list_SEMICOLON_expression_,
    match_arm: $ =>
      choice(seq($.WILDCARD, $.COLON, $._logical_expression),
        seq($.constructor_binding, $.COLON, $._logical_expression)),
    match_arms: $ => seq($.ALT, $.match_arm, optional($.match_arms)),
    maybe_qualified_constructor: $ =>
      seq($._constructor, optional(seq($.DOT, $._constructor))),
    metadata_block: $ =>
      seq($.BEGIN_METADATA, optional($.LAW_TEXT), optional($.code),
        $.END_CODE),
    _mult_expression: $ =>
      choice($._unop_expression,
        seq($._mult_expression, $._mult_op, $._unop_expression)),
    _mult_op: $ =>
      choice($.MULT, $.DIV, $.MULTDEC, $.DIVDEC, $.MULTMONEY, $.DIVMONEY,
        $.DIVDURATION),
    _num_literal: $ => choice($.INT_LITERAL, $.DECIMAL_LITERAL),
    optional_binding: $ =>
      choice(seq($.OF, $._ident),
        seq($.OF, $.maybe_qualified_constructor, $.constructor_binding)),
    _primitive_expression: $ =>
      choice($._small_expression, $.CARDINAL, $.struct_or_enum_inject,
        seq($.LSQUARE,
          optional($._loption_separated_nonempty_list_SEMICOLON_expression__),
          $.RSQUARE)),
    qident: $ => $._separated_nonempty_list_DOT_ident_,
    rule: $ =>
      seq(optional($.label), optional($.exception_to), $.RULE, $.rule_expr,
        optional($.condition_consequence), optional($.state),
        $.rule_consequence),
    rule_consequence: $ => seq(optional($.NOT), $.FILLED),
    rule_expr: $ => seq($.qident, optional($.definition_parameters)),
    scope_decl_item: $ =>
      choice(seq($.scope_decl_item_attribute, $._ident, $.CONTENT, $._typ,
               optional($.struct_scope_func), repeat($.state)),
        seq($._ident, $.SCOPE, $._constructor),
        seq($.scope_decl_item_attribute, $._ident, $.CONDITION,
          optional($.struct_scope_func), repeat($.state))),
    scope_decl_item_attribute: $ =>
      choice(seq($._scope_decl_item_attribute_input,
               optional($._scope_decl_item_attribute_output)), $.INTERNAL,
        $.OUTPUT),
    _scope_decl_item_attribute_input: $ => choice($.CONTEXT, $.INPUT),
    _scope_decl_item_attribute_output: $ => $.OUTPUT,
    _scope_item: $ =>
      choice($.rule, $.definition, seq($.ASSERTION, $.assertion)),
    scope_use_condition: $ => seq($.UNDER_CONDITION, $.expression),
    _separated_nonempty_list_ALT_struct_content_field_: $ =>
      choice($.struct_content_field,
        seq($.struct_content_field, $.ALT,
          $._separated_nonempty_list_ALT_struct_content_field_)),
    _separated_nonempty_list_DOT_ident_: $ =>
      choice($._ident,
        seq($._ident, $.DOT, $._separated_nonempty_list_DOT_ident_)),
    _separated_nonempty_list_SEMICOLON_expression_: $ =>
      choice($.expression,
        seq($.expression, $.SEMICOLON,
          $._separated_nonempty_list_SEMICOLON_expression_)),
    _small_expression: $ =>
      choice($._atomic_expression,
        seq($._small_expression, $.DOT, optional(seq($._constructor, $.DOT)),
          $._ident)),
    _source_file_item: $ =>
      choice($.law_text, seq($.BEGIN_CODE, optional($.code), $.END_CODE),
        $._law_heading, $.metadata_block,
        seq($.BEGIN_DIRECTIVE, $.LAW_INCLUDE, $.COLON,
          repeat1($.DIRECTIVE_ARG), optional($.AT_PAGE), $.END_DIRECTIVE)),
    state: $ => seq($.STATE, $._ident),
    struct_content_field: $ => seq($._ident, $.COLON, $._logical_expression),
    struct_inject_content: $ =>
      seq($.LBRACKET, $.ALT,
        $._separated_nonempty_list_ALT_struct_content_field_, $.RBRACKET),
    struct_or_enum_inject: $ =>
      choice(seq($._constructor, optional(seq($.DOT, $._constructor)),
               optional($.enum_inject_content)),
        seq($._constructor, $.struct_inject_content)),
    struct_scope: $ =>
      seq($.struct_scope_base, optional($.struct_scope_func)),
    struct_scope_base: $ =>
      choice(seq($.DATA, $._ident, $.CONTENT, $._typ),
        seq($._condition_pos, $._ident)),
    struct_scope_func: $ => seq($.DEPENDS, $._typ),
    _sum_expression: $ =>
      choice($._mult_expression,
        seq($._sum_expression, $._sum_op, $._mult_expression)),
    _sum_op: $ =>
      choice($.PLUSDURATION, $.MINUSDURATION, $.PLUSDATE, $.MINUSDATE,
        $.PLUSMONEY, $.MINUSMONEY, $.PLUSDEC, $.MINUSDEC, $.PLUS, $.MINUS,
        $.PLUSPLUS),
    _typ: $ => choice($._typ_base, seq($._collection_marked, $._typ)),
    _typ_base: $ =>
      choice($.INTEGER, $.BOOLEAN, $.MONEY, $.DURATION, $.TEXT, $.DECIMAL,
        $.DATE, $._constructor),
    _unit_literal: $ => choice($.PERCENT, $.YEAR, $.MONTH, $.DAY),
    _unop: $ =>
      choice($.NOT, $.MINUS, $.MINUSDEC, $.MINUSMONEY, $.MINUSDURATION),
    _unop_expression: $ =>
      choice($._base_expression, seq($._unop, $._unop_expression)),
    _variation_type: $ => choice($.INCREASING, $.DECREASING),
    ALL: $ => tokens.ALL,
    ALT: $ => tokens.ALT,
    AND: $ => tokens.AND,
    ASSERTION: $ => tokens.ASSERTION,
    AT_PAGE: $ => tokens.AT_PAGE,
    BEGIN_CODE: $ => tokens.BEGIN_CODE,
    BEGIN_DIRECTIVE: $ => tokens.BEGIN_DIRECTIVE,
    BEGIN_METADATA: $ => tokens.BEGIN_METADATA,
    BOOLEAN: $ => tokens.BOOLEAN,
    BY: $ => tokens.BY,
    CARDINAL: $ => tokens.CARDINAL,
    COLLECTION: $ => tokens.COLLECTION,
    COLON: $ => tokens.COLON,
    CONDITION: $ => tokens.CONDITION,
    CONSEQUENCE: $ => tokens.CONSEQUENCE,
    CONSTRUCTOR: $ => tokens.CONSTRUCTOR,
    CONTENT: $ => tokens.CONTENT,
    CONTEXT: $ => tokens.CONTEXT,
    DATA: $ => tokens.DATA,
    DATE: $ => tokens.DATE,
    DAY: $ => tokens.DAY,
    DECIMAL: $ => tokens.DECIMAL,
    DECIMAL_LITERAL: $ => tokens.DECIMAL_LITERAL,
    DECLARATION: $ => tokens.DECLARATION,
    DECREASING: $ => tokens.DECREASING,
    DEFINED_AS: $ => tokens.DEFINED_AS,
    DEFINITION: $ => tokens.DEFINITION,
    DEPENDS: $ => tokens.DEPENDS,
    DIRECTIVE_ARG: $ => tokens.DIRECTIVE_ARG,
    DIV: $ => tokens.DIV,
    DIVDEC: $ => tokens.DIVDEC,
    DIVDURATION: $ => tokens.DIVDURATION,
    DIVMONEY: $ => tokens.DIVMONEY,
    DOT: $ => tokens.DOT,
    DURATION: $ => tokens.DURATION,
    ELSE: $ => tokens.ELSE,
    END_CODE: $ => tokens.END_CODE,
    END_DIRECTIVE: $ => tokens.END_DIRECTIVE,
    ENUM: $ => tokens.ENUM,
    EQUAL: $ => tokens.EQUAL,
    EXCEPTION: $ => tokens.EXCEPTION,
    EXISTS: $ => tokens.EXISTS,
    FALSE: $ => tokens.FALSE,
    FILLED: $ => tokens.FILLED,
    FILTER: $ => tokens.FILTER,
    FIXED: $ => tokens.FIXED,
    FOR: $ => tokens.FOR,
    GREATER: $ => tokens.GREATER,
    GREATER_DATE: $ => tokens.GREATER_DATE,
    GREATER_DEC: $ => tokens.GREATER_DEC,
    GREATER_DURATION: $ => tokens.GREATER_DURATION,
    GREATER_EQUAL: $ => tokens.GREATER_EQUAL,
    GREATER_EQUAL_DATE: $ => tokens.GREATER_EQUAL_DATE,
    GREATER_EQUAL_DEC: $ => tokens.GREATER_EQUAL_DEC,
    GREATER_EQUAL_DURATION: $ => tokens.GREATER_EQUAL_DURATION,
    GREATER_EQUAL_MONEY: $ => tokens.GREATER_EQUAL_MONEY,
    GREATER_MONEY: $ => tokens.GREATER_MONEY,
    IDENT: $ => tokens.IDENT,
    IF: $ => tokens.IF,
    IN: $ => tokens.IN,
    INCREASING: $ => tokens.INCREASING,
    INIT: $ => tokens.INIT,
    INPUT: $ => tokens.INPUT,
    INTEGER: $ => tokens.INTEGER,
    INTERNAL: $ => tokens.INTERNAL,
    INT_LITERAL: $ => tokens.INT_LITERAL,
    LABEL: $ => tokens.LABEL,
    LAW_HEADING: $ => tokens.LAW_HEADING,
    LAW_INCLUDE: $ => tokens.LAW_INCLUDE,
    LAW_TEXT: $ => prec.right(1,tokens.LAW_TEXT),
    LBRACKET: $ => tokens.LBRACKET,
    LESSER: $ => tokens.LESSER,
    LESSER_DATE: $ => tokens.LESSER_DATE,
    LESSER_DEC: $ => tokens.LESSER_DEC,
    LESSER_DURATION: $ => tokens.LESSER_DURATION,
    LESSER_EQUAL: $ => tokens.LESSER_EQUAL,
    LESSER_EQUAL_DATE: $ => tokens.LESSER_EQUAL_DATE,
    LESSER_EQUAL_DEC: $ => tokens.LESSER_EQUAL_DEC,
    LESSER_EQUAL_DURATION: $ => tokens.LESSER_EQUAL_DURATION,
    LESSER_EQUAL_MONEY: $ => tokens.LESSER_EQUAL_MONEY,
    LESSER_MONEY: $ => tokens.LESSER_MONEY,
    LPAREN: $ => tokens.LPAREN,
    LSQUARE: $ => tokens.LSQUARE,
    MAP: $ => tokens.MAP,
    MATCH: $ => tokens.MATCH,
    MAXIMUM: $ => tokens.MAXIMUM,
    MINIMUM: $ => tokens.MINIMUM,
    MINUS: $ => tokens.MINUS,
    MINUSDATE: $ => tokens.MINUSDATE,
    MINUSDEC: $ => tokens.MINUSDEC,
    MINUSDURATION: $ => tokens.MINUSDURATION,
    MINUSMONEY: $ => tokens.MINUSMONEY,
    MONEY: $ => tokens.MONEY,
    MONEY_AMOUNT: $ => tokens.MONEY_AMOUNT,
    MONTH: $ => tokens.MONTH,
    MULT: $ => tokens.MULT,
    MULTDEC: $ => tokens.MULTDEC,
    MULTMONEY: $ => tokens.MULTMONEY,
    NOT: $ => tokens.NOT,
    NOT_EQUAL: $ => tokens.NOT_EQUAL,
    OF: $ => tokens.OF,
    OR: $ => tokens.OR,
    OUTPUT: $ => tokens.OUTPUT,
    PERCENT: $ => tokens.PERCENT,
    PLUS: $ => tokens.PLUS,
    PLUSDATE: $ => tokens.PLUSDATE,
    PLUSDEC: $ => tokens.PLUSDEC,
    PLUSDURATION: $ => tokens.PLUSDURATION,
    PLUSMONEY: $ => tokens.PLUSMONEY,
    PLUSPLUS: $ => tokens.PLUSPLUS,
    RBRACKET: $ => tokens.RBRACKET,
    RPAREN: $ => tokens.RPAREN,
    RSQUARE: $ => tokens.RSQUARE,
    RULE: $ => tokens.RULE,
    SCOPE: $ => tokens.SCOPE,
    SEMICOLON: $ => tokens.SEMICOLON,
    STATE: $ => tokens.STATE,
    STRUCT: $ => tokens.STRUCT,
    SUCH: $ => tokens.SUCH,
    SUM: $ => tokens.SUM,
    TEXT: $ => tokens.TEXT,
    THAT: $ => tokens.THAT,
    THEN: $ => tokens.THEN,
    TRUE: $ => tokens.TRUE,
    UNDER_CONDITION: $ => tokens.UNDER_CONDITION,
    VARIES: $ => tokens.VARIES,
    VERTICAL: $ => tokens.VERTICAL,
    WE_HAVE: $ => tokens.WE_HAVE,
    WILDCARD: $ => tokens.WILDCARD,
    WITH: $ => tokens.WITH,
    WITH_V: $ => tokens.WITH_V,
    XOR: $ => tokens.XOR,
    YEAR: $ => tokens.YEAR,
    }, rules)
  })
