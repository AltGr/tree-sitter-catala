









module.exports = grammar({
  name: 'Catala',
  inline: $ => [
    // $.code,
    $.law_text,
  ],
  word: $ => $.IDENT,
  rules: {
    source_file: $ => repeat1($._source_file_item),
    aggregate: $ =>
      seq($.aggregate_func, $.FOR, $._ident, $.IN, $._primitive_expression,
        $.OF, $._base_expression),
    aggregate_func: $ =>
      choice(seq($.CONTENT, $.MAXIMUM, $._typ_base, $.INIT,
               $._primitive_expression),
        seq($.CONTENT, $.MINIMUM, $._typ_base, $.INIT,
          $._primitive_expression),
        seq($.MAXIMUM, $._typ_base, $.INIT, $._primitive_expression),
        seq($.MINIMUM, $._typ_base, $.INIT, $._primitive_expression),
        seq($.SUM, $._typ_base), $.CARDINAL, $.FILTER, $.MAP),
    assertion: $ =>
      choice(seq(optional($.condition_consequence), $._assertion_base),
        seq($.FIXED, $.qident, $.BY, $._ident),
        seq($.VARIES, $.qident, $.WITH_V, $._base_expression,
          optional($._variation_type))),
    _assertion_base: $ => $.expression,
    _atomic_expression: $ =>
      choice($.IDENT, $.literal, seq($.LPAREN, $.expression, $.RPAREN)),
    _base_expression: $ =>
      choice($._primitive_expression, $.aggregate,
        seq($._primitive_expression, $.OF, $._base_expression),
        seq($._primitive_expression, $.WITH, $.constructor_binding),
        seq($._primitive_expression, $.IN, $._base_expression)),
    code: $ => repeat1($.code_item),
    code_item: $ =>
      choice(seq($.SCOPE, $._constructor, optional($.scope_use_condition),
               $.COLON, repeat1($._scope_item)),
        seq($.DECLARATION, $.STRUCT, $._constructor, $.COLON,
          repeat($.struct_scope)),
        seq($.DECLARATION, $.SCOPE, $._constructor, $.COLON,
          repeat1($.scope_decl_item)),
        seq($.DECLARATION, $.ENUM, $._constructor, $.COLON,
          repeat($.enum_decl_line))),
    _collection_marked: $ => $.COLLECTION,
    _compare_expression: $ =>
      choice($._sum_expression,
        seq($._sum_expression, $._compare_op, $._compare_expression)),
    _compare_op: $ =>
      choice($.LESSER, $.LESSER_EQUAL, $.GREATER, $.GREATER_EQUAL,
        $.LESSER_DEC, $.LESSER_EQUAL_DEC, $.GREATER_DEC, $.GREATER_EQUAL_DEC,
        $.LESSER_MONEY, $.LESSER_EQUAL_MONEY, $.GREATER_MONEY,
        $.GREATER_EQUAL_MONEY, $.LESSER_DATE, $.LESSER_EQUAL_DATE,
        $.GREATER_DATE, $.GREATER_EQUAL_DATE, $.LESSER_DURATION,
        $.LESSER_EQUAL_DURATION, $.GREATER_DURATION,
        $.GREATER_EQUAL_DURATION, $.EQUAL, $.NOT_EQUAL),
    condition: $ => seq($.UNDER_CONDITION, $.expression),
    condition_consequence: $ => seq($.condition, $.CONSEQUENCE),
    _condition_pos: $ => $.CONDITION,
    _constructor: $ => $.CONSTRUCTOR,
    constructor_binding: $ =>
      seq($.maybe_qualified_constructor, $.optional_binding),
    _date_int: $ => $.INT_LITERAL,
    definition: $ =>
      seq(optional($.label), optional($.exception_to), $.DEFINITION,
        $.qident, optional($.definition_parameters), optional($.state),
        optional($.condition_consequence), $.DEFINED_AS, $.expression),
    definition_parameters: $ => seq($.OF, $._ident),
    enum_decl_line: $ =>
      seq($.ALT, $._constructor, optional($.enum_decl_line_payload)),
    enum_decl_line_payload: $ => seq($.CONTENT, $._typ),
    enum_inject_content: $ => seq($.CONTENT, $._small_expression),
    exception_to: $ => seq($.EXCEPTION, optional($._ident)),
    _exists_marked: $ => $.EXISTS,
    exists_prefix: $ =>
      seq($._exists_marked, $._ident, $.IN, $._primitive_expression, $.SUCH,
        $.THAT),
    expression: $ =>
      choice(seq($.exists_prefix, $.expression),
        seq($.forall_prefix, $.expression),
        seq($.MATCH, $._primitive_expression, $.WITH, $.match_arms),
        seq($.IF, $.expression, $.THEN, $.expression, $.ELSE, $.expression),
        $._logical_expression),
    for_all_marked: $ => seq($.FOR, $.ALL),
    forall_prefix: $ =>
      seq($.for_all_marked, $._ident, $.IN, $._primitive_expression,
        $.WE_HAVE),
    _ident: $ => $.IDENT,
    label: $ => seq($.LABEL, $._ident),
    _law_heading: $ => $.LAW_HEADING,
    law_text: $ => prec(2,repeat1($.LAW_TEXT)),
    literal: $ =>
      choice(seq($._num_literal, optional($._unit_literal)), $.MONEY_AMOUNT,
        seq($.VERTICAL, $._date_int, $.MINUS, $._date_int, $.MINUS,
          $._date_int, $.VERTICAL), $.TRUE, $.FALSE),
    _logical_and_op: $ => $.AND,
    _logical_atom: $ => $._compare_expression,
    _logical_expression: $ =>
      choice($._logical_or_expression,
        seq($._logical_or_expression, $._logical_and_op,
          $._logical_expression)),
    _logical_or_expression: $ =>
      choice($._logical_atom,
        seq($._logical_atom, $._logical_or_op, $._logical_or_expression)),
    _logical_or_op: $ => choice($.OR, $.XOR),
    _loption_separated_nonempty_list_SEMICOLON_expression__: $ =>
      $._separated_nonempty_list_SEMICOLON_expression_,
    match_arm: $ =>
      choice(seq($.WILDCARD, $.COLON, $._logical_expression),
        seq($.constructor_binding, $.COLON, $._logical_expression)),
    match_arms: $ => seq($.ALT, $.match_arm, $.match_arms),
    maybe_qualified_constructor: $ =>
      seq($._constructor, optional(seq($.DOT, $._constructor))),
    metadata_block: $ =>
      seq($.BEGIN_METADATA, optional($.law_text), optional($.code), $.END_CODE),
    _mult_expression: $ =>
      choice($._unop_expression,
        seq($._mult_expression, $._mult_op, $._unop_expression)),
    _mult_op: $ =>
      choice($.MULT, $.DIV, $.MULTDEC, $.DIVDEC, $.MULTMONEY, $.DIVMONEY,
        $.DIVDURATION),
    _num_literal: $ => choice($.INT_LITERAL, $.DECIMAL_LITERAL),
    optional_binding: $ =>
      choice(seq($.OF, $._ident),
        seq($.OF, $.maybe_qualified_constructor, $.constructor_binding)),
    _primitive_expression: $ =>
      choice($._small_expression, $.CARDINAL, $.struct_or_enum_inject,
        seq($.LSQUARE,
          $._loption_separated_nonempty_list_SEMICOLON_expression__,
          $.RSQUARE)),
    qident: $ => $._separated_nonempty_list_DOT_ident_,
    rule: $ =>
      seq(optional($.label), optional($.exception_to), $.RULE, $.rule_expr,
        optional($.condition_consequence), optional($.state),
        $.rule_consequence),
    rule_consequence: $ => seq(optional($.NOT), $.FILLED),
    rule_expr: $ => seq($.qident, optional($.definition_parameters)),
    scope_decl_item: $ =>
      choice(seq($.scope_decl_item_attribute, $._ident, $.CONTENT, $._typ,
               optional($.struct_scope_func), repeat($.state)),
        seq($._ident, $.SCOPE, $._constructor),
        seq($.scope_decl_item_attribute, $._ident, $.CONDITION,
          optional($.struct_scope_func), repeat($.state))),
    scope_decl_item_attribute: $ =>
      choice(seq($._scope_decl_item_attribute_input,
               $._scope_decl_item_attribute_output), $.INTERNAL, $.OUTPUT),
    _scope_decl_item_attribute_input: $ => choice($.CONTEXT, $.INPUT),
    _scope_decl_item_attribute_output: $ => $.OUTPUT,
    _scope_item: $ =>
      choice($.rule, $.definition, seq($.ASSERTION, $.assertion)),
    scope_use_condition: $ => seq($.UNDER_CONDITION, $.expression),
    _separated_nonempty_list_ALT_struct_content_field_: $ =>
      choice($.struct_content_field,
        seq($.struct_content_field, $.ALT,
          $._separated_nonempty_list_ALT_struct_content_field_)),
    _separated_nonempty_list_DOT_ident_: $ =>
      choice($._ident,
        seq($._ident, $.DOT, $._separated_nonempty_list_DOT_ident_)),
    _separated_nonempty_list_SEMICOLON_expression_: $ =>
      choice($.expression,
        seq($.expression, $.SEMICOLON,
          $._separated_nonempty_list_SEMICOLON_expression_)),
    _small_expression: $ =>
      choice($._atomic_expression,
        seq($._small_expression, $.DOT, optional(seq($._constructor, $.DOT)),
          $._ident)),
    _source_file_item: $ =>
      choice($.law_text, seq($.BEGIN_CODE, optional($.code), $.END_CODE),
        $._law_heading, $.metadata_block,
        seq($.BEGIN_DIRECTIVE, $.LAW_INCLUDE, $.COLON,
          repeat1($.DIRECTIVE_ARG), optional($.AT_PAGE), $.END_DIRECTIVE)),
    state: $ => seq($.STATE, $._ident),
    struct_content_field: $ => seq($._ident, $.COLON, $._logical_expression),
    struct_inject_content: $ =>
      seq($.LBRACKET, $.ALT,
        $._separated_nonempty_list_ALT_struct_content_field_, $.RBRACKET),
    struct_or_enum_inject: $ =>
      choice(seq($._constructor, optional(seq($.DOT, $._constructor)),
               optional($.enum_inject_content)),
        seq($._constructor, $.struct_inject_content)),
    struct_scope: $ =>
      seq($.struct_scope_base, optional($.struct_scope_func)),
    struct_scope_base: $ =>
      choice(seq($.DATA, $._ident, $.CONTENT, $._typ),
        seq($._condition_pos, $._ident)),
    struct_scope_func: $ => seq($.DEPENDS, $._typ),
    _sum_expression: $ =>
      choice($._mult_expression,
        seq($._sum_expression, $._sum_op, $._mult_expression)),
    _sum_op: $ =>
      choice($.PLUSDURATION, $.MINUSDURATION, $.PLUSDATE, $.MINUSDATE,
        $.PLUSMONEY, $.MINUSMONEY, $.PLUSDEC, $.MINUSDEC, $.PLUS, $.MINUS,
        $.PLUSPLUS),
    _typ: $ => choice($._typ_base, seq($._collection_marked, $._typ)),
    _typ_base: $ =>
      choice($.INTEGER, $.BOOLEAN, $.MONEY, $.DURATION, $.TEXT, $.DECIMAL,
        $.DATE, $._constructor),
    _unit_literal: $ => choice($.PERCENT, $.YEAR, $.MONTH, $.DAY),
    _unop: $ =>
      choice($.NOT, $.MINUS, $.MINUSDEC, $.MINUSMONEY, $.MINUSDURATION),
    _unop_expression: $ =>
      choice($._base_expression, seq($._unop, $._unop_expression)),
    _variation_type: $ => choice($.INCREASING, $.DECREASING),
    ALL: $ =>  "all" ,
    ALT: $ =>  '--' ,
    AND: $ =>  "and" ,
    ASSERTION: $ =>  "assertion" ,
    AT_PAGE: $ =>  'todo' ,
    BEGIN_CODE: $ =>  '```catala' ,
    BEGIN_DIRECTIVE: $ =>  '>' ,
    BEGIN_METADATA: $ =>  '```catala-metadata' ,
    BOOLEAN: $ =>  "boolean" ,
    BY: $ =>  "by" ,
    CARDINAL: $ =>  "number" ,
    COLLECTION: $ =>  "collection" ,
    COLON: $ =>  ':' ,
    CONDITION: $ =>  "condition" ,
    CONSEQUENCE: $ =>  "consequence" ,
    CONSTRUCTOR: $ =>  /[A-Z][A-Za-z0-9_']*/ ,
    CONTENT: $ =>  "content" ,
    CONTEXT: $ =>  "context" ,
    DATA: $ =>  "data" ,
    DATE: $ =>  "date" ,
    DAY: $ =>  "day" ,
    DECIMAL: $ =>  "decimal" ,
    DECIMAL_LITERAL: $ =>  /[0-9]+.[0-9]*/ ,
    DECLARATION: $ =>  "declaration" ,
    DECREASING: $ =>  "decreasing" ,
    DEFINED_AS: $ =>  "equals" ,
    DEFINITION: $ =>  "definition" ,
    DEPENDS: $ =>  "depends on" ,
    DIRECTIVE_ARG: $ =>  /\S+/ ,
    DIV: $ =>  '/' ,
    DIVDEC: $ =>  '/.' ,
    DIVDURATION: $ =>  '/^' ,
    DIVMONEY: $ =>  '/$' ,
    DOT: $ =>  '.' ,
    DURATION: $ =>  "duration" ,
    ELSE: $ =>  "else" ,
    END_CODE: $ =>  '```' ,
    END_DIRECTIVE: $ =>  '\n' ,
    ENUM: $ =>  "enumeration" ,
    EOF: $ =>  'thisIsNotEOF' ,
    EQUAL: $ =>  '=' ,
    EXCEPTION: $ =>  "exception" ,
    EXISTS: $ =>  "exists" ,
    FALSE: $ =>  "false" ,
    FILLED: $ =>  "fulfilled" ,
    FILTER: $ =>  "filter" ,
    FIXED: $ =>  "fixed" ,
    FOR: $ =>  "for" ,
    GREATER: $ =>  '>' ,
    GREATER_DATE: $ =>  '>@' ,
    GREATER_DEC: $ =>  '>.' ,
    GREATER_DURATION: $ =>  '>^' ,
    GREATER_EQUAL: $ =>  '>=' ,
    GREATER_EQUAL_DATE: $ =>  '>=@' ,
    GREATER_EQUAL_DEC: $ =>  '>=.' ,
    GREATER_EQUAL_DURATION: $ =>  '>=^' ,
    GREATER_EQUAL_MONEY: $ =>  '>=$' ,
    GREATER_MONEY: $ =>  '>$' ,
    IDENT: $ =>  /[a-z][a-zA-Z0-9_']*/ ,
    IF: $ =>  "if" ,
    IN: $ =>  "in" ,
    INCREASING: $ =>  "increasing" ,
    INIT: $ =>  "initial" ,
    INPUT: $ =>  "input" ,
    INTEGER: $ =>  "integer" ,
    INTERNAL: $ =>  "internal" ,
    INT_LITERAL: $ =>  /[0-9]+/ ,
    LABEL: $ =>  "label" ,
    LAW_HEADING: $ =>  /#+\s*\S+/ ,
    LAW_INCLUDE: $ =>  'Include' ,
    LAW_TEXT: $ =>  /\S+/ ,
    LBRACKET: $ =>  '{' ,
    LESSER: $ =>  '<' ,
    LESSER_DATE: $ =>  '<@' ,
    LESSER_DEC: $ =>  '<.' ,
    LESSER_DURATION: $ =>  '<^' ,
    LESSER_EQUAL: $ =>  '<=' ,
    LESSER_EQUAL_DATE: $ =>  '<=@' ,
    LESSER_EQUAL_DEC: $ =>  '<=.' ,
    LESSER_EQUAL_DURATION: $ =>  '<=^' ,
    LESSER_EQUAL_MONEY: $ =>  '<=$' ,
    LESSER_MONEY: $ =>  '<$' ,
    LPAREN: $ =>  '(' ,
    LSQUARE: $ =>  '[' ,
    MAP: $ =>  "map" ,
    MATCH: $ =>  "match" ,
    MAXIMUM: $ =>  "maximum" ,
    MINIMUM: $ =>  "minimum" ,
    MINUS: $ =>  '-' ,
    MINUSDATE: $ =>  '-@' ,
    MINUSDEC: $ =>  '-.' ,
    MINUSDURATION: $ =>  '-^' ,
    MINUSMONEY: $ =>  '-$' ,
    MONEY: $ =>  "money" ,
    MONEY_AMOUNT: $ =>  /\$[0-9]([0-9,]*[0-9])?(\.[0-9]{0,2})?/ ,
    MONTH: $ =>  "month" ,
    MULT: $ =>  '*' ,
    MULTDEC: $ =>  '*.' ,
    MULTMONEY: $ =>  '*$' ,
    NOT: $ =>  "not" ,
    NOT_EQUAL: $ =>  '!=' ,
    OF: $ =>  "of" ,
    OR: $ =>  "or" ,
    OUTPUT: $ =>  "output" ,
    PERCENT: $ =>  '%' ,
    PLUS: $ =>  '+' ,
    PLUSDATE: $ =>  '+@' ,
    PLUSDEC: $ =>  '+.' ,
    PLUSDURATION: $ =>  '+^' ,
    PLUSMONEY: $ =>  '+$' ,
    PLUSPLUS: $ =>  '++' ,
    RBRACKET: $ =>  '}' ,
    RPAREN: $ =>  ')' ,
    RSQUARE: $ =>  ']' ,
    RULE: $ =>  "rule" ,
    SCOPE: $ =>  "scope" ,
    SEMICOLON: $ =>  ';' ,
    STATE: $ =>  "state" ,
    STRUCT: $ =>  "structure" ,
    SUCH: $ =>  "such" ,
    SUM: $ =>  "sum" ,
    TEXT: $ =>  "text" ,
    THAT: $ =>  "that" ,
    THEN: $ =>  "then" ,
    TRUE: $ =>  "true" ,
    UNDER_CONDITION: $ =>  "under condition" ,
    VARIES: $ =>  "varies" ,
    VERTICAL: $ =>  '|' ,
    WE_HAVE: $ =>  "we have" ,
    WILDCARD: $ =>  "anything" ,
    WITH: $ =>  "with pattern" ,
    WITH_V: $ =>  "with" ,
    XOR: $ =>  "xor" ,
    YEAR: $ =>  "year" ,
    }
  })
