









module.exports = grammar({
  name: 'Catala',
  inline: $ => [$.code,$.law_text],
  word: $ => $.IDENT,
  rules: {
    source_file: $ => choice(seq($.source_file_item, $.source_file), $.EOF),
    aggregate: $ =>
      seq($.aggregate_func, $.FOR, $.ident, $.IN, $.primitive_expression,
        $.OF, $.base_expression),
    aggregate_func: $ =>
      choice(seq($.CONTENT, $.MAXIMUM, $.typ_base, $.INIT,
               $.primitive_expression),
        seq($.CONTENT, $.MINIMUM, $.typ_base, $.INIT, $.primitive_expression),
        seq($.MAXIMUM, $.typ_base, $.INIT, $.primitive_expression),
        seq($.MINIMUM, $.typ_base, $.INIT, $.primitive_expression),
        seq($.SUM, $.typ_base), $.CARDINAL, $.FILTER, $.MAP),
    assertion: $ =>
      choice(seq(optional($.condition_consequence), $.assertion_base),
        seq($.FIXED, $.qident, $.BY, $.ident),
        seq($.VARIES, $.qident, $.WITH_V, $.base_expression,
          optional($.variation_type))),
    assertion_base: $ => $.expression,
    atomic_expression: $ =>
      choice($.IDENT, $.literal, seq($.LPAREN, $.expression, $.RPAREN)),
    base_expression: $ =>
      choice($.primitive_expression, $.aggregate,
        seq($.primitive_expression, $.OF, $.base_expression),
        seq($.primitive_expression, $.WITH, $.constructor_binding),
        seq($.primitive_expression, $.IN, $.base_expression)),
    code: $ => repeat1($.code_item),
    code_item: $ =>
      choice(seq($.SCOPE, $.constructor, optional($.scope_use_condition),
               $.COLON, repeat1($.scope_item)),
        seq($.DECLARATION, $.STRUCT, $.constructor, $.COLON,
          repeat($.struct_scope)),
        seq($.DECLARATION, $.SCOPE, $.constructor, $.COLON,
          repeat1($.scope_decl_item)),
        seq($.DECLARATION, $.ENUM, $.constructor, $.COLON,
          repeat($.enum_decl_line))),
    collection_marked: $ => $.COLLECTION,
    compare_expression: $ =>
      choice($.sum_expression,
        seq($.sum_expression, $.compare_op, $.compare_expression)),
    compare_op: $ =>
      choice($.LESSER, $.LESSER_EQUAL, $.GREATER, $.GREATER_EQUAL,
        $.LESSER_DEC, $.LESSER_EQUAL_DEC, $.GREATER_DEC, $.GREATER_EQUAL_DEC,
        $.LESSER_MONEY, $.LESSER_EQUAL_MONEY, $.GREATER_MONEY,
        $.GREATER_EQUAL_MONEY, $.LESSER_DATE, $.LESSER_EQUAL_DATE,
        $.GREATER_DATE, $.GREATER_EQUAL_DATE, $.LESSER_DURATION,
        $.LESSER_EQUAL_DURATION, $.GREATER_DURATION,
        $.GREATER_EQUAL_DURATION, $.EQUAL, $.NOT_EQUAL),
    condition: $ => seq($.UNDER_CONDITION, $.expression),
    condition_consequence: $ => seq($.condition, $.CONSEQUENCE),
    condition_pos: $ => $.CONDITION,
    constructor: $ => $.CONSTRUCTOR,
    constructor_binding: $ =>
      seq($.maybe_qualified_constructor, $.optional_binding),
    date_int: $ => $.INT_LITERAL,
    definition: $ =>
      seq(optional($.label), optional($.exception_to), $.DEFINITION,
        $.qident, optional($.definition_parameters), optional($.state),
        optional($.condition_consequence), $.DEFINED_AS, $.expression),
    definition_parameters: $ => seq($.OF, $.ident),
    enum_decl_line: $ =>
      seq($.ALT, $.constructor, optional($.enum_decl_line_payload)),
    enum_decl_line_payload: $ => seq($.CONTENT, $.typ),
    enum_inject_content: $ => seq($.CONTENT, $.small_expression),
    exception_to: $ => seq($.EXCEPTION, optional($.ident)),
    exists_marked: $ => $.EXISTS,
    exists_prefix: $ =>
      seq($.exists_marked, $.ident, $.IN, $.primitive_expression, $.SUCH,
        $.THAT),
    expression: $ =>
      choice(seq($.exists_prefix, $.expression),
        seq($.forall_prefix, $.expression),
        seq($.MATCH, $.primitive_expression, $.WITH, $.match_arms),
        seq($.IF, $.expression, $.THEN, $.expression, $.ELSE, $.expression),
        $.logical_expression),
    for_all_marked: $ => seq($.FOR, $.ALL),
    forall_prefix: $ =>
      seq($.for_all_marked, $.ident, $.IN, $.primitive_expression, $.WE_HAVE),
    ident: $ => $.IDENT,
    label: $ => seq($.LABEL, $.ident),
    law_heading: $ => $.LAW_HEADING,
    law_text: $ => prec(2,repeat1($.LAW_TEXT)),
    literal: $ =>
      choice(seq($.num_literal, optional($.unit_literal)), $.MONEY_AMOUNT,
        seq($.VERTICAL, $.date_int, $.MINUS, $.date_int, $.MINUS, $.date_int,
          $.VERTICAL), $.TRUE, $.FALSE),
    logical_and_op: $ => $.AND,
    logical_atom: $ => $.compare_expression,
    logical_expression: $ =>
      choice($.logical_or_expression,
        seq($.logical_or_expression, $.logical_and_op, $.logical_expression)),
    logical_or_expression: $ =>
      choice($.logical_atom,
        seq($.logical_atom, $.logical_or_op, $.logical_or_expression)),
    logical_or_op: $ => choice($.OR, $.XOR),
    _loption_separated_nonempty_list_SEMICOLON_expression__: $ =>
      $._separated_nonempty_list_SEMICOLON_expression_,
    match_arm: $ =>
      choice(seq($.WILDCARD, $.COLON, $.logical_expression),
        seq($.constructor_binding, $.COLON, $.logical_expression)),
    match_arms: $ => seq($.ALT, $.match_arm, $.match_arms),
    maybe_qualified_constructor: $ =>
      seq($.constructor, optional(seq($.DOT, $.constructor))),
    metadata_block: $ =>
      seq($.BEGIN_METADATA, optional($.law_text), optional($.code), $.END_CODE),
    mult_expression: $ =>
      choice($.unop_expression,
        seq($.mult_expression, $.mult_op, $.unop_expression)),
    mult_op: $ =>
      choice($.MULT, $.DIV, $.MULTDEC, $.DIVDEC, $.MULTMONEY, $.DIVMONEY,
        $.DIVDURATION),
    num_literal: $ => choice($.INT_LITERAL, $.DECIMAL_LITERAL),
    optional_binding: $ =>
      choice(seq($.OF, $.ident),
        seq($.OF, $.maybe_qualified_constructor, $.constructor_binding)),
    primitive_expression: $ =>
      choice($.small_expression, $.CARDINAL, $.struct_or_enum_inject,
        seq($.LSQUARE,
          $._loption_separated_nonempty_list_SEMICOLON_expression__,
          $.RSQUARE)),
    qident: $ => $._separated_nonempty_list_DOT_ident_,
    rule: $ =>
      seq(optional($.label), optional($.exception_to), $.RULE, $.rule_expr,
        optional($.condition_consequence), optional($.state),
        $.rule_consequence),
    rule_consequence: $ => seq(optional($.NOT), $.FILLED),
    rule_expr: $ => seq($.qident, optional($.definition_parameters)),
    scope_decl_item: $ =>
      choice(seq($.scope_decl_item_attribute, $.ident, $.CONTENT, $.typ,
               optional($.struct_scope_func), repeat($.state)),
        seq($.ident, $.SCOPE, $.constructor),
        seq($.scope_decl_item_attribute, $.ident, $.CONDITION,
          optional($.struct_scope_func), repeat($.state))),
    scope_decl_item_attribute: $ =>
      choice(seq($.scope_decl_item_attribute_input,
               $.scope_decl_item_attribute_output), $.INTERNAL, $.OUTPUT),
    scope_decl_item_attribute_input: $ => choice($.CONTEXT, $.INPUT),
    scope_decl_item_attribute_output: $ => $.OUTPUT,
    scope_item: $ =>
      choice($.rule, $.definition, seq($.ASSERTION, $.assertion)),
    scope_use_condition: $ => seq($.UNDER_CONDITION, $.expression),
    _separated_nonempty_list_ALT_struct_content_field_: $ =>
      choice($.struct_content_field,
        seq($.struct_content_field, $.ALT,
          $._separated_nonempty_list_ALT_struct_content_field_)),
    _separated_nonempty_list_DOT_ident_: $ =>
      choice($.ident,
        seq($.ident, $.DOT, $._separated_nonempty_list_DOT_ident_)),
    _separated_nonempty_list_SEMICOLON_expression_: $ =>
      choice($.expression,
        seq($.expression, $.SEMICOLON,
          $._separated_nonempty_list_SEMICOLON_expression_)),
    small_expression: $ =>
      choice($.atomic_expression,
        seq($.small_expression, $.DOT, optional(seq($.constructor, $.DOT)),
          $.ident)),
    source_file_item: $ =>
      choice($.law_text, seq($.BEGIN_CODE, optional($.code), $.END_CODE),
        $.law_heading, $.metadata_block,
        seq($.BEGIN_DIRECTIVE, $.LAW_INCLUDE, $.COLON,
          repeat1($.DIRECTIVE_ARG), optional($.AT_PAGE), $.END_DIRECTIVE)),
    state: $ => seq($.STATE, $.ident),
    struct_content_field: $ => seq($.ident, $.COLON, $.logical_expression),
    struct_inject_content: $ =>
      seq($.LBRACKET, $.ALT,
        $._separated_nonempty_list_ALT_struct_content_field_, $.RBRACKET),
    struct_or_enum_inject: $ =>
      choice(seq($.constructor, optional(seq($.DOT, $.constructor)),
               optional($.enum_inject_content)),
        seq($.constructor, $.struct_inject_content)),
    struct_scope: $ =>
      seq($.struct_scope_base, optional($.struct_scope_func)),
    struct_scope_base: $ =>
      choice(seq($.DATA, $.ident, $.CONTENT, $.typ),
        seq($.condition_pos, $.ident)),
    struct_scope_func: $ => seq($.DEPENDS, $.typ),
    sum_expression: $ =>
      choice($.mult_expression,
        seq($.sum_expression, $.sum_op, $.mult_expression)),
    sum_op: $ =>
      choice($.PLUSDURATION, $.MINUSDURATION, $.PLUSDATE, $.MINUSDATE,
        $.PLUSMONEY, $.MINUSMONEY, $.PLUSDEC, $.MINUSDEC, $.PLUS, $.MINUS,
        $.PLUSPLUS),
    typ: $ => choice($.typ_base, seq($.collection_marked, $.typ)),
    typ_base: $ =>
      choice($.INTEGER, $.BOOLEAN, $.MONEY, $.DURATION, $.TEXT, $.DECIMAL,
        $.DATE, $.constructor),
    unit_literal: $ => choice($.PERCENT, $.YEAR, $.MONTH, $.DAY),
    unop: $ =>
      choice($.NOT, $.MINUS, $.MINUSDEC, $.MINUSMONEY, $.MINUSDURATION),
    unop_expression: $ =>
      choice($.base_expression, seq($.unop, $.unop_expression)),
    variation_type: $ => choice($.INCREASING, $.DECREASING),
    ALL: $ =>  "all" ,
    ALT: $ =>  '--' ,
    AND: $ =>  "and" ,
    ASSERTION: $ =>  "assertion" ,
    AT_PAGE: $ =>  'todo' ,
    BEGIN_CODE: $ =>  '```catala' ,
    BEGIN_DIRECTIVE: $ =>  '>' ,
    BEGIN_METADATA: $ =>  '```catala-metadata' ,
    BOOLEAN: $ =>  "boolean" ,
    BY: $ =>  "by" ,
    CARDINAL: $ =>  "number" ,
    COLLECTION: $ =>  "collection" ,
    COLON: $ =>  ':' ,
    CONDITION: $ =>  "condition" ,
    CONSEQUENCE: $ =>  "consequence" ,
    CONSTRUCTOR: $ =>  /[A-Z][A-Za-z0-9_']*/ ,
    CONTENT: $ =>  "content" ,
    CONTEXT: $ =>  "context" ,
    DATA: $ =>  "data" ,
    DATE: $ =>  "date" ,
    DAY: $ =>  "day" ,
    DECIMAL: $ =>  "decimal" ,
    DECIMAL_LITERAL: $ =>  /[0-9]+.[0-9]*/ ,
    DECLARATION: $ =>  "declaration" ,
    DECREASING: $ =>  "decreasing" ,
    DEFINED_AS: $ =>  "equals" ,
    DEFINITION: $ =>  "definition" ,
    DEPENDS: $ =>  "depends on" ,
    DIRECTIVE_ARG: $ =>  /\S+/ ,
    DIV: $ =>  '/' ,
    DIVDEC: $ =>  '/.' ,
    DIVDURATION: $ =>  '/^' ,
    DIVMONEY: $ =>  '/$' ,
    DOT: $ =>  '.' ,
    DURATION: $ =>  "duration" ,
    ELSE: $ =>  "else" ,
    END_CODE: $ =>  '```' ,
    END_DIRECTIVE: $ =>  '\n' ,
    ENUM: $ =>  "enumeration" ,
    EOF: $ =>  'thisIsNotEOF' ,
    EQUAL: $ =>  '=' ,
    EXCEPTION: $ =>  "exception" ,
    EXISTS: $ =>  "exists" ,
    FALSE: $ =>  "false" ,
    FILLED: $ =>  "fulfilled" ,
    FILTER: $ =>  "filter" ,
    FIXED: $ =>  "fixed" ,
    FOR: $ =>  "for" ,
    GREATER: $ =>  '>' ,
    GREATER_DATE: $ =>  '>@' ,
    GREATER_DEC: $ =>  '>.' ,
    GREATER_DURATION: $ =>  '>^' ,
    GREATER_EQUAL: $ =>  '>=' ,
    GREATER_EQUAL_DATE: $ =>  '>=@' ,
    GREATER_EQUAL_DEC: $ =>  '>=.' ,
    GREATER_EQUAL_DURATION: $ =>  '>=^' ,
    GREATER_EQUAL_MONEY: $ =>  '>=$' ,
    GREATER_MONEY: $ =>  '>$' ,
    IDENT: $ =>  /[a-z][a-zA-Z0-9_']*/ ,
    IF: $ =>  "if" ,
    IN: $ =>  "in" ,
    INCREASING: $ =>  "increasing" ,
    INIT: $ =>  "initial" ,
    INPUT: $ =>  "input" ,
    INTEGER: $ =>  "integer" ,
    INTERNAL: $ =>  "internal" ,
    INT_LITERAL: $ =>  /[0-9]+/ ,
    LABEL: $ =>  "label" ,
    LAW_HEADING: $ =>  /#+\s*\S+/ ,
    LAW_INCLUDE: $ =>  'Include' ,
    LAW_TEXT: $ =>  /[^`]/ ,
    LBRACKET: $ =>  '{' ,
    LESSER: $ =>  '<' ,
    LESSER_DATE: $ =>  '<@' ,
    LESSER_DEC: $ =>  '<.' ,
    LESSER_DURATION: $ =>  '<^' ,
    LESSER_EQUAL: $ =>  '<=' ,
    LESSER_EQUAL_DATE: $ =>  '<=@' ,
    LESSER_EQUAL_DEC: $ =>  '<=.' ,
    LESSER_EQUAL_DURATION: $ =>  '<=^' ,
    LESSER_EQUAL_MONEY: $ =>  '<=$' ,
    LESSER_MONEY: $ =>  '<$' ,
    LPAREN: $ =>  '(' ,
    LSQUARE: $ =>  '[' ,
    MAP: $ =>  "map" ,
    MATCH: $ =>  "match" ,
    MAXIMUM: $ =>  "maximum" ,
    MINIMUM: $ =>  "minimum" ,
    MINUS: $ =>  '-' ,
    MINUSDATE: $ =>  '-@' ,
    MINUSDEC: $ =>  '-.' ,
    MINUSDURATION: $ =>  '-^' ,
    MINUSMONEY: $ =>  '-$' ,
    MONEY: $ =>  "money" ,
    MONEY_AMOUNT: $ =>  /\$[0-9]([0-9,]*[0-9])?(\.[0-9]{0,2})?/ ,
    MONTH: $ =>  "month" ,
    MULT: $ =>  '*' ,
    MULTDEC: $ =>  '*.' ,
    MULTMONEY: $ =>  '*$' ,
    NOT: $ =>  "not" ,
    NOT_EQUAL: $ =>  '!=' ,
    OF: $ =>  "of" ,
    OR: $ =>  "or" ,
    OUTPUT: $ =>  "output" ,
    PERCENT: $ =>  '%' ,
    PLUS: $ =>  '+' ,
    PLUSDATE: $ =>  '+@' ,
    PLUSDEC: $ =>  '+.' ,
    PLUSDURATION: $ =>  '+^' ,
    PLUSMONEY: $ =>  '+$' ,
    PLUSPLUS: $ =>  '++' ,
    RBRACKET: $ =>  '}' ,
    RPAREN: $ =>  ')' ,
    RSQUARE: $ =>  ']' ,
    RULE: $ =>  "rule" ,
    SCOPE: $ =>  "scope" ,
    SEMICOLON: $ =>  ';' ,
    STATE: $ =>  "state" ,
    STRUCT: $ =>  "structure" ,
    SUCH: $ =>  "such" ,
    SUM: $ =>  "sum" ,
    TEXT: $ =>  "text" ,
    THAT: $ =>  "that" ,
    THEN: $ =>  "then" ,
    TRUE: $ =>  "true" ,
    UNDER_CONDITION: $ =>  "under condition" ,
    VARIES: $ =>  "varies" ,
    VERTICAL: $ =>  '|' ,
    WE_HAVE: $ =>  "we have" ,
    WILDCARD: $ =>  "anything" ,
    WITH: $ =>  "with pattern" ,
    WITH_V: $ =>  "with" ,
    XOR: $ =>  "xor" ,
    YEAR: $ =>  "year" ,
    }
  })
